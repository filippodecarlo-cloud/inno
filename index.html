<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Inno Player">
    <meta name="theme-color" content="#764ba2">
    <meta name="description" content="Player audio per l'inno con controllo volume progressivo">

    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">

    <title>Riproduttore Inno</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 20px 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 380px;
            width: 100%;
            position: relative;
            /* For absolute settings btn */
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 20px;
        }

        .track-info {
            margin-bottom: 10px;
            padding: 10px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 10px;
            border-left: 4px solid #764ba2;
        }

        .track-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }

        .track-subtitle {
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
        }

        .track-artist {
            font-size: 11px;
            color: #888;
            font-style: italic;
            margin-bottom: 8px;
        }

        .track-description {
            font-size: 11px;
            color: #764ba2;
            font-weight: 500;
            line-height: 1.4;
        }

        .controls-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
        }

        #playButton {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50%;
            width: 100px;
            height: 100px;
            font-size: 40px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        #playButton:active {
            transform: scale(0.95);
        }

        #playButton:hover {
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.6);
        }

        #playButton.playing {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        #playButton.waiting {
            background: linear-gradient(135deg, #fbc2eb 0%, #a6c1ee 100%);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        #restartButton {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 5px 15px rgba(17, 153, 142, 0.4);
        }

        #restartButton:active {
            transform: scale(0.95);
        }

        #restartButton:hover {
            box-shadow: 0 8px 25px rgba(17, 153, 142, 0.6);
        }

        .progress-container {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin: 15px 0;
            overflow: hidden;
            cursor: pointer;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            width: 0%;
            transition: width 0.1s linear;
        }

        .status {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
            min-height: 20px;
        }

        .volume-section {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 12px;
        }

        .volume-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .volume-meter {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 60px;
            gap: 3px;
            margin-bottom: 10px;
        }

        .volume-bar {
            width: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            transition: all 0.15s ease;
        }

        .volume-bar.active {
            background: linear-gradient(180deg, #f5576c 0%, #f093fb 50%, #667eea 100%);
        }

        .volume-bar:nth-child(1) {
            height: 20%;
        }

        .volume-bar:nth-child(2) {
            height: 30%;
        }

        .volume-bar:nth-child(3) {
            height: 40%;
        }

        .volume-bar:nth-child(4) {
            height: 50%;
        }

        .volume-bar:nth-child(5) {
            height: 60%;
        }

        .volume-bar:nth-child(6) {
            height: 70%;
        }

        .volume-bar:nth-child(7) {
            height: 80%;
        }

        .volume-bar:nth-child(8) {
            height: 90%;
        }

        .volume-bar:nth-child(9) {
            height: 95%;
        }

        .volume-bar:nth-child(10) {
            height: 100%;
        }

        .volume-percentage {
            font-size: 24px;
            font-weight: bold;
            color: #764ba2;
        }

        .volume-debug {
            font-size: 10px;
            color: #999;
            margin-top: 5px;
        }

        .settings-section {
            margin-top: 10px;
            padding: 0;
            background: none;
        }

        .settings-title {
            font-size: 14px;
            color: #333;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .setting-row:last-child {
            margin-bottom: 0;
        }

        .setting-label {
            font-size: 13px;
            color: #666;
            flex: 1;
            text-align: left;
        }

        .setting-input {
            width: 80px;
            padding: 8px 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
            transition: border-color 0.2s;
        }

        .setting-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .setting-unit {
            font-size: 12px;
            color: #999;
            margin-left: 5px;
            width: 30px;
        }

        /* Compact Settings Logic */
        .toggle-settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #999;
            z-index: 10;
        }

        .settings-content {
            display: none;
            margin-top: 15px;
            border-top: 1px solid #eee;
            padding-top: 15px;
        }

        .settings-content.show {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .settings-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .settings-btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .settings-btn.save {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .settings-btn.load {
            background: #e0e0e0;
            color: #333;
        }

        .settings-btn:active {
            transform: scale(0.95);
        }

        .settings-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .settings-message {
            font-size: 11px;
            color: #11998e;
            margin-top: 8px;
            min-height: 16px;
        }

        .install-prompt {
            display: none;
            margin-top: 15px;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            color: white;
            font-size: 12px;
            cursor: pointer;
        }

        .install-prompt.show {
            display: block;
        }

        .logo {
            width: 80px;
            height: auto;
            margin-bottom: 10px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        @media (max-width: 360px) {
            .container {
                padding: 20px 15px;
            }

            h1 {
                font-size: 20px;
            }

            #playButton {
                width: 70px;
                height: 70px;
                font-size: 28px;
            }
        }

        #visualizer {
            width: 100%;
            height: 40px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 10px;
        }
    </style>
</head>

<body>
    <div class="container">
        <img src="Logo_universita_firenze.png" alt="Logo Università di Firenze" class="logo">
        <h1>Riproduttore Inno</h1>

        <div class="track-info">
            <p class="track-title">Academic Festival Overture, Op. 80</p>
            <p class="track-subtitle">Maestoso (parte finale)</p>
            <p class="track-artist">Berliner Philharmoniker dir. Claudio Abbado</p>
            <p class="track-description">Inno dell'Università degli Studi di Firenze<br>per la proclamazione delle
                lauree</p>
        </div>

        <div class="controls-row">
            <button id="restartButton" title="Ricomincia da capo">↺</button>
            <button id="playButton">▶</button>
        </div>

        <div class="progress-container" id="progressContainer">
            <div class="progress-bar" id="progressBar"></div>
        </div>

        <div class="status" id="status">Premi per iniziare</div>

        <div class="volume-section">
            <div class="volume-label">Volume</div>
            <div class="volume-meter" id="volumeMeter">
                <div class="volume-bar active"></div>
                <div class="volume-bar active"></div>
                <div class="volume-bar active"></div>
                <div class="volume-bar active"></div>
                <div class="volume-bar active"></div>
                <div class="volume-bar active"></div>
                <div class="volume-bar active"></div>
                <div class="volume-bar active"></div>
                <div class="volume-bar active"></div>
                <div class="volume-bar active"></div>
            </div>
            <div class="volume-percentage" id="volumePercentage">100%</div>
            <div class="volume-debug" id="volumeDebug">Vol. reale: 56%</div>
        </div>

        <canvas id="visualizer" width="300" height="40"></canvas>

        <button id="toggleSettings" class="toggle-settings-btn" title="Impostazioni">⚙️</button>

        <div class="settings-section">
            <div id="settingsContent" class="settings-content">
                <div class="settings-title">Impostazioni Volume</div>
                <div class="setting-row">
                    <span class="setting-label">Incremento massimo</span>
                    <input type="number" id="volumeIncrement" class="setting-input" value="100" min="0" max="100">
                    <span class="setting-unit">%</span>
                </div>
                <div class="setting-row">
                    <span class="setting-label">Inizio incremento</span>
                    <input type="number" id="fadeTime" class="setting-input" value="35" min="1" max="60">
                    <span class="setting-unit">sec</span>
                </div>
                <div class="setting-row">
                    <span class="setting-label">Fine incremento</span>
                    <input type="number" id="fadeEndTime" class="setting-input" value="25" min="0" max="60">
                    <span class="setting-unit">sec</span>
                </div>
                <div class="setting-row">
                    <span class="setting-label">Ritardo avvio</span>
                    <input type="number" id="startDelay" class="setting-input" value="3" min="0" max="60">
                    <span class="setting-unit">sec</span>
                </div>
                <div class="settings-buttons">
                    <button class="settings-btn save" id="saveSettings">Salva</button>
                    <button class="settings-btn load" id="loadSettings">Carica</button>
                </div>
                <div class="settings-message" id="settingsMessage"></div>
            </div>
        </div>

        <div class="install-prompt" id="installPrompt">
            Tocca per installare l'app
        </div>
    </div>

    <audio id="audio" preload="auto">
        <source src="inno.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Elements
        const playButton = document.getElementById('playButton');
        const restartButton = document.getElementById('restartButton');
        const audio = document.getElementById('audio');
        const status = document.getElementById('status');
        const progressBar = document.getElementById('progressBar');
        const progressContainer = document.getElementById('progressContainer');
        const volumeMeter = document.getElementById('volumeMeter');
        const volumePercentage = document.getElementById('volumePercentage');
        const volumeIncrementInput = document.getElementById('volumeIncrement');
        const fadeTimeInput = document.getElementById('fadeTime');
        const fadeEndTimeInput = document.getElementById('fadeEndTime');
        const startDelayInput = document.getElementById('startDelay');
        const installPrompt = document.getElementById('installPrompt');
        const volumeDebug = document.getElementById('volumeDebug');
        const saveSettingsBtn = document.getElementById('saveSettings');
        const loadSettingsBtn = document.getElementById('loadSettings');
        const settingsMessage = document.getElementById('settingsMessage');
        const toggleSettingsBtn = document.getElementById('toggleSettings');
        const settingsContent = document.getElementById('settingsContent');

        let isPlaying = false;
        let isWaiting = false;
        let delayTimer = null;
        let deferredPrompt = null;
        let wakeLock = null;

        // Audio Context & Visualizer
        let audioContext = null;
        let analyser = null;
        let pcmData = null;
        let sourceNode = null;

        // Wake Lock Function
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake Lock attivato');
                    wakeLock.addEventListener('release', () => {
                        console.log('Wake Lock rilasciato');
                    });
                }
            } catch (err) {
                console.error(`${err.name}, ${err.message}`);
            }
        }

        async function releaseWakeLock() {
            if (wakeLock !== null) {
                await wakeLock.release();
                wakeLock = null;
            }
        }

        // Handle visibility change
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await requestWakeLock();
            }
        });

        // Initialize Audio Context (user interaction required)
        function initAudioContext() {
            // Check if running locally via file:// protocol
            if (window.location.protocol === 'file:') {
                console.warn('Visualizer disabilitato su protocollo file:// per preservare l\'audio.');
                const canvas = document.getElementById('visualizer');
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#666';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Visualizer non disponibile in locale', canvas.width / 2, canvas.height / 2 + 4);
                return;
            }

            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 64; // Small size for simple bars

                    // Allow CORS for audio if possible (helps on some servers)
                    audio.crossOrigin = "anonymous";

                    sourceNode = audioContext.createMediaElementSource(audio);
                    sourceNode.connect(analyser);
                    analyser.connect(audioContext.destination);

                    pcmData = new Uint8Array(analyser.frequencyBinCount);
                    drawVisualizer();
                } catch (e) {
                    console.error('Errore AudioContext:', e);
                }
            } else if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function drawVisualizer() {
            if (!analyser) return;

            requestAnimationFrame(drawVisualizer);
            analyser.getByteFrequencyData(pcmData);

            const canvas = document.getElementById('visualizer');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const barWidth = (width / pcmData.length) * 2.5;
            let x = 0;

            ctx.clearRect(0, 0, width, height);

            for (let i = 0; i < pcmData.length; i++) {
                const barHeight = (pcmData[i] / 255) * height;

                // Dynamic Gradient
                const gradient = ctx.createLinearGradient(0, height, 0, height - barHeight);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');

                ctx.fillStyle = gradient;
                // Draw rounded bars
                ctx.beginPath();
                ctx.roundRect(x, height - barHeight, barWidth - 2, barHeight, 3);
                ctx.fill();

                x += barWidth;
            }
        }

        // Save settings to localStorage
        function saveSettings() {
            const settings = {
                volumeIncrement: volumeIncrementInput.value,
                fadeStartTime: fadeTimeInput.value,
                fadeEndTime: fadeEndTimeInput.value,
                startDelay: startDelayInput.value
            };
            localStorage.setItem('innoPlayerSettings', JSON.stringify(settings));
            showMessage('Impostazioni salvate');
        }

        // Load settings from localStorage
        function loadSettings() {
            const saved = localStorage.getItem('innoPlayerSettings');
            if (saved) {
                const settings = JSON.parse(saved);
                volumeIncrementInput.value = settings.volumeIncrement || 100;
                fadeTimeInput.value = settings.fadeStartTime || 35;
                fadeEndTimeInput.value = settings.fadeEndTime || 25;
                startDelayInput.value = (settings.startDelay !== undefined) ? settings.startDelay : 3;
                showMessage('Impostazioni caricate');

                // Update base volume with new settings
                const maxIncrement = parseFloat(volumeIncrementInput.value) || 100;
                const baseVolume = 1.0 / (1 + maxIncrement / 100);
                audio.volume = baseVolume;
                updateVolumeMeter(100, baseVolume);
            } else {
                showMessage('Nessuna impostazione salvata');
            }
        }

        // Show temporary message
        function showMessage(text) {
            settingsMessage.textContent = text;
            setTimeout(() => {
                settingsMessage.textContent = '';
            }, 2000);
        }

        // Auto-load settings on page load
        window.addEventListener('load', () => {
            const saved = localStorage.getItem('innoPlayerSettings');
            if (saved) {
                const settings = JSON.parse(saved);
                volumeIncrementInput.value = settings.volumeIncrement || 100;
                fadeTimeInput.value = settings.fadeStartTime || 35;
                fadeEndTimeInput.value = settings.fadeEndTime || 25;
                startDelayInput.value = (settings.startDelay !== undefined) ? settings.startDelay : 3;
            }
        });

        // Button event listeners
        saveSettingsBtn.addEventListener('click', saveSettings);
        loadSettingsBtn.addEventListener('click', loadSettings);

        toggleSettingsBtn.addEventListener('click', () => {
            settingsContent.classList.toggle('show');
            // Scroll to settings if opening
            if (settingsContent.classList.contains('show')) {
                setTimeout(() => {
                    settingsContent.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100);
            }
        });

        // Play/Pause button
        playButton.addEventListener('click', function () {
            // Caso 1: In attesa -> Annulla
            if (isWaiting) {
                clearTimeout(delayTimer);
                isWaiting = false;
                playButton.textContent = '▶';
                playButton.classList.remove('waiting');
                status.textContent = 'Avvio annullato';
                return;
            }

            // Caso 2: In riproduzione -> Pausa
            if (isPlaying) {
                audio.pause();
                isPlaying = false;
                playButton.textContent = '▶';
                playButton.classList.remove('playing');
                status.textContent = 'In pausa';
                releaseWakeLock(); // Release lock on pause
                return;
            }

            // Caso 3: Fermo -> Avvia (con o senza ritardo)
            const delaySeconds = parseInt(startDelayInput.value) || 0;

            if (delaySeconds > 0) {
                startCountdown(delaySeconds);
            } else {
                startPlayback();
            }
        });

        function startCountdown(seconds) {
            initAudioContext(); // Pre-init audio context on click
            requestWakeLock();  // Lock screen during countdown

            isWaiting = true;
            playButton.classList.add('waiting');
            playButton.textContent = '⏳';

            let remaining = seconds;
            status.textContent = `Avvio tra ${remaining} secondi...`;

            function tick() {
                remaining--;
                if (remaining > 0) {
                    status.textContent = `Avvio tra ${remaining} secondi...`;
                    delayTimer = setTimeout(tick, 1000);
                } else {
                    startPlayback();
                }
            }

            delayTimer = setTimeout(tick, 1000);
        }

        function startPlayback() {
            initAudioContext(); // Ensure audio context is ready
            requestWakeLock();  // Lock screen

            isWaiting = false;
            isPlaying = true;

            playButton.classList.remove('waiting');
            playButton.classList.add('playing');
            playButton.textContent = '⏸';
            status.textContent = 'In riproduzione...';

            audio.play().catch(e => {
                console.error("Autoplay bloccato o errore:", e);
                status.textContent = "Errore avvio audio";
                isPlaying = false;
                playButton.classList.remove('playing');
                playButton.textContent = '▶';
            });
        }

        // Restart button
        restartButton.addEventListener('click', function () {
            // Se c'è un countdown in corso, annullalo
            if (isWaiting) {
                clearTimeout(delayTimer);
                isWaiting = false;
                playButton.classList.remove('waiting');
                releaseWakeLock();
            }

            audio.currentTime = 0;
            // Reset to base volume
            const maxIncrement = parseFloat(volumeIncrementInput.value) || 100;
            const baseVolume = 1.0 / (1 + maxIncrement / 100);
            audio.volume = baseVolume;
            updateVolumeMeter(100, baseVolume);

            if (!isPlaying) {
                audio.play();
                isPlaying = true;
                playButton.textContent = '⏸';
                playButton.classList.add('playing');
            }

            status.textContent = 'Ricominciato da capo';
        });

        // Click on progress bar to seek
        progressContainer.addEventListener('click', function (e) {
            const rect = progressContainer.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const width = rect.width;
            const percentage = clickX / width;

            audio.currentTime = percentage * audio.duration;
        });

        // Update volume meter visual
        function updateVolumeMeter(percentage, realVolume) {
            const bars = volumeMeter.querySelectorAll('.volume-bar');
            const activeBars = Math.round((percentage / 180) * 10); // Scale to 180% max

            bars.forEach((bar, index) => {
                if (index < activeBars) {
                    bar.classList.add('active');
                } else {
                    bar.classList.remove('active');
                }
            });

            volumePercentage.textContent = `${Math.round(percentage)}%`;
            if (realVolume !== undefined) {
                volumeDebug.textContent = `Vol. reale: ${Math.round(realVolume * 100)}%`;
            }
        }

        audio.addEventListener('loadedmetadata', function () {
            console.log('Durata audio:', audio.duration, 'secondi');
            // Set initial base volume
            const maxIncrement = parseFloat(volumeIncrementInput.value) || 100;
            const baseVolume = 1.0 / (1 + maxIncrement / 100);
            audio.volume = baseVolume;
            updateVolumeMeter(100, baseVolume);
        });

        audio.addEventListener('timeupdate', function () {
            const currentTime = audio.currentTime;
            const duration = audio.duration;

            if (!duration) return;

            // Update progress bar
            const progressPercent = (currentTime / duration) * 100;
            progressBar.style.width = `${progressPercent}%`;

            const timeRemaining = duration - currentTime;

            // Get settings values
            const fadeStartTime = parseFloat(fadeTimeInput.value) || 35;
            const fadeEndTime = parseFloat(fadeEndTimeInput.value) || 25;
            const maxIncrement = parseFloat(volumeIncrementInput.value) || 100;

            // Calculate base volume so that increment reaches 1.0
            // e.g., 80% increment: baseVolume = 1.0 / 1.8 = 0.556
            const baseVolume = 1.0 / (1 + maxIncrement / 100);
            const fadeDuration = fadeStartTime - fadeEndTime;

            // Volume fade in final seconds
            if (timeRemaining <= fadeStartTime && timeRemaining > fadeEndTime && fadeDuration > 0) {
                const fadeProgress = 1 - ((timeRemaining - fadeEndTime) / fadeDuration);
                // Increase from baseVolume to 1.0
                const currentVolume = baseVolume + (fadeProgress * (1.0 - baseVolume));
                audio.volume = currentVolume;

                // Display percentage relative to base (100% at start, up to 100+increment at end)
                const displayPercentage = (currentVolume / baseVolume) * 100;
                updateVolumeMeter(displayPercentage, currentVolume);
            } else if (timeRemaining <= fadeEndTime) {
                // After fade end, keep at max volume
                audio.volume = 1.0;
                updateVolumeMeter(100 + maxIncrement, 1.0);
            } else {
                audio.volume = baseVolume;
                if (timeRemaining > fadeStartTime) {
                    updateVolumeMeter(100, baseVolume);
                }
            }

            // Update time remaining
            if (isPlaying) {
                const minutes = Math.floor(timeRemaining / 60);
                const seconds = Math.floor(timeRemaining % 60);
                status.textContent = `Tempo rimanente: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        });

        audio.addEventListener('ended', function () {
            isPlaying = false;
            releaseWakeLock(); // Release lock on end
            playButton.textContent = '▶';
            playButton.classList.remove('playing');
            status.textContent = 'Completato - Premi per ricominciare';
            progressBar.style.width = '0%';
            audio.currentTime = 0;
            // Reset to base volume
            const maxIncrement = parseFloat(volumeIncrementInput.value) || 100;
            const baseVolume = 1.0 / (1 + maxIncrement / 100);
            audio.volume = baseVolume;
            updateVolumeMeter(100, baseVolume);
        });

        audio.addEventListener('error', function (e) {
            status.textContent = 'Errore nel caricamento del file';
            console.error('Errore audio:', e);
        });

        // PWA Install prompt
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            installPrompt.classList.add('show');
        });

        installPrompt.addEventListener('click', async () => {
            if (!deferredPrompt) return;

            deferredPrompt.prompt();
            const { outcome } = await deferredPrompt.userChoice;

            if (outcome === 'accepted') {
                installPrompt.classList.remove('show');
            }

            deferredPrompt = null;
        });

        // Register Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registrato:', registration.scope);
                    })
                    .catch(error => {
                        console.log('Registrazione Service Worker fallita:', error);
                    });
            });
        }
    </script>
</body>

</html>